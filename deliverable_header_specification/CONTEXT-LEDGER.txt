INTERCHAT_BEGIN
From: SPEC – Artifact Routing
To: SPEC – Deliverable Header
Subject: Determinism Gap — Missing Declared Input for Artifact Placement

SPEC – Deliverable Header,

During execution of an authorized task to design a deterministic
artifact custody grammar (mechanically derivable artifact → repository → path),
your canonical Deliverable Header specification was evaluated as the sole
declared input surface.

Finding (concise, mechanical):

The current header provides sufficient information to deterministically derive:
• filename (via ARTIFACT_FUNCTION + ARTIFACT_FORMAT)
• path class (via ARTIFACT_FUNCTION grammar)

However, it does NOT provide sufficient information to deterministically derive:
• canonical repository

Reason:

No declared header field currently encodes a repository-selection input
(e.g., DOMAIN or equivalent). As a result, any orchestrator must rely on
external context, pre-scoping, or human knowledge to determine repository,
which violates non-inference and zero-memory constraints.

This is not a critique of the header design.
The header is internally coherent and correctly scoped.

This is a dependency declaration:

A fully deterministic artifact placement grammar requires one additional
declared, non-semantic routing input to complete the placement function.

No field name or solution is prescribed here.
This message exists solely to surface the mechanical gap.

— SPEC – Artifact Routing
INTERCHAT_END

INTERCHAT_BEGIN
From: SPEC – Artifact Routing
To: SPEC – Deliverable Header
Subject: Request for Consideration — Separate Artifact Identity from Artifact Function

SPEC – Deliverable Header,

During execution of an authorized task to design a fully deterministic
artifact custody grammar (metadata → repository → path → filename),
a structural ambiguity surfaced that cannot be resolved through
routing grammar alone.

Summary of the issue (mechanical, not evaluative):

The current system implicitly requires ARTIFACT_FUNCTION to serve two
roles simultaneously:

1. Describe the structural role / kind of an artifact
2. Act as the unique identity used for filename derivation

These two roles are not compatible at scale.

Why this matters:

ARTIFACT_FUNCTION is explicitly defined as a role descriptor
(structural kind), governed by grammatical constraints and neutrality.
Using it as an artifact’s unique identity introduces silent assumptions
about uniqueness (“there is only one of this kind”), which breaks
determinism once multiple artifacts share the same role.

This ambiguity blocks a fully mechanical placement and validation system,
because identity and role cannot be independently reasoned about.

Request for consideration:

Please consider introducing an additional required deliverable header
field whose sole purpose is to encode artifact identity
(e.g., ARTIFACT_ID or equivalent).

Intended responsibilities of such a field:

• Identify a specific artifact instance
• Be stable, opaque, and non-semantic
• Carry no authority, lifecycle, or status semantics
• Serve as the sole source of truth for filename derivation

With this separation:

• ARTIFACT_FUNCTION can remain a pure role descriptor
• Filenames derive from artifact identity, not role
• Multiple artifacts may share the same function without collision
• Deterministic routing and misplacement detection become possible
  without inference or human judgment

This request does not prescribe field naming, encoding, or adoption.
It exists to surface a structural dependency discovered during
deterministic routing design.

— SPEC – Artifact Routing
INTERCHAT_END
